Checks={Client={},SlotHubLimit={},Nick={},Clone={},Share={}}
--[[
Client, share, slots, hubs & limiter check module for LawMaker by bastya_elvtars
Some ideas from Gemini by NightLitch
Hub/slot checking was my first ability in lua, and got it from nErBoS :-)
Also much code for the first version from ConsoleMoon by [NL]Pur
Clone check originally by Mutor, rewritten by bastya_elvtars and NightLitch.
DCGUI check originally by Optimus and plop (I am unsure whether it's up-to-date.)
=================================================================================
HUBOWNERS: redirect addresses are grabbed from PtokaX from now on.
You can set them through the redirect plugin.
As there is no limit check in PtokaX, the limit redirects go to the default redirect address.
=================================================================================
DEVELOPERS: the clone check is called only on NewUserConnected.
It would be fatal to call it on MyINFOArrival, wouldn't it? :-P
Also, if a user is disconnected, the script returns "shit"
It stops the loop of checks in the core file. Please keep an eye on this if
you wanna rewrite this file (as I am sure some of you do. :D)
---------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------
Ok, let's start (this is what you are waiting for probably)!
Since this script is called every time a user sends a MyINFO or connects, it has to be optimized.
As such, it may seem harder to configure, but I am sure You can do the job.
Do not forget to read the manual as it will help you understand many things here.
  

                               CLIENT CHECKING STUFF
                              =======================
Set the minimum dc++ and mod version, does not apply for oDC and StrongDC.
(I am unsure whether you should allow oDC at all.)
The min. version should be 0.401, you probably agree.
Note that DC++k CDM is 0.251, so immune the user wanting 2 use it.
However, better use DCDM++.
Either way, no scripts can substitute a CDM, so use one.
Oh, almost forgot: immuned users skip all client checks.
]]

-- 1 disconnects, 2 redirects.
-- It goes for all (incl. op only clients)
-- I can extend this further if needed
-- NOTE: fake tags will still be banned, if set below, and it should be set.
Checks.Client.BadClientToDo=2

Checks.Client.DCppMinVersion=0.401

Checks.Client.DCGUIMinVersion = 2.12 -- minimum DCGUI version (after the 0 :)) - is the Valknut tag different?

-- To ban users who have a faked hub count in their tag, set to 1  (otherwise disconnects them only).
-- N. B.: this is far from accurate (no false positives however), so USE A CDM!
Checks.Client.BanFakeTag=1 

-- Set this to 1 in order to enable bot ban messages in main.
Checks.SeeBotBan=1 

-- Clients only for operators, set 1 if yes, 0 if not, and watch out for the comma!
Checks.Client.OpClients=
  { 
    ["DC++"]=0, -- standard client
    ["BCDC++"]=0, -- LUA and limiter support
    ["oDC"]=0, -- latest is 0.306-based, cosmetised DC++
    ["DCDM++"]=1, -- the leading client detector
    ["rmDC++"]=0, -- a GPL-violating multisource client. PtokaX will not allow to connect it, but I leave it here.
    ["zDC++"]=0, -- multisource op client
    ["StrongDC++"]=0, -- mulisource op client
    [".PhantomDC++"]=1, -- a great BCDC++ mod, unfortunately stopped @ 0.306
    ["DC++k CDM"]=1, -- 0.251-based client checker
    ["iDC++"]=1, -- italian op client
    ["neXtDC++"]=0, -- hungarian multisource client, stopped @ 0.306
    ["DCGUI"]=0, -- client for Linux, also called valknut
    ["DC:PRO"]=0, -- non-DC++-based buggy client
    ["DC@fe++"]=0, -- a BCDC++ mod
    ["ReverseConnect"]=0, -- multisource DC++ mod
    ["MS++V"]=0, -- same as zDC++, only difference I know of is the default language :)
    ["SoßeR++"]=0, -- op client, mod of R2++
    ["Sasser"]=1, -- op client made by Sulan
    ["LDC++"]=0, -- multisource client, LUA capable
    ["PeerWebDC"]=0, -- StrongDC++ mod (practically speaking, a ripoff)
    ["SababaDC++"]=0, -- another multisource client, from the Mid-East :)
    ["Zion++"]=0, -- another StrongDC  (or RevConnect?) mod
    ["R2++"]=1,
  }
 
-- Disallowed clients, set 1 if disallowed, 0 if not, and watch out for the comma!
-- Even operators cannot use these, regardless of the above settings.
Checks.Client.BadClients=
  {
    ["DC++"]=0,
    ["BCDC++"]=0,
    ["oDC"]=0,
    ["DCDM++"]=0,
    ["rmDC++"]=1,
    ["zDC++"]=1,
    ["StrongDC++"]=1,
    [".PhantomDC++"]=0,
    ["DC++k CDM"]=0,
    ["iDC++"]=0,
    ["neXtDC++"]=1,
    ["DCGUI"]=0,
    ["DC:PRO"]=1,
    ["DC@fe++"]=0,
    ["ReverseConnect"]=1,
    ["MS++V"]=1,
    ["SoßeR++"]=0,
    ["Sasser"]=0,
    ["LDC++"]=0,
    ["PeerWebDC"]=1,
    ["SababaDC++"]=1,
    ["Zion++"]=1,
    ["R2++"]=0,
  }
 
--[[
                           SLOT/HUB/LIMIT CHECKING STUFF
                          =============================
The next option defines who GET checked for slots, hubs, limiter
]]

Checks.SlotHubLimit.SlotHubLevel=2
Checks.SlotHubLimit.LimitLevel=2
--[[
If you set the following to 1, op hubs count into total no. of hubs a certain user is in.
Personally i leave it enabled.]]
Checks.SlotHubLimit.OpHubsCount=1 


--[[
If you set the max_slots to 0, then the connection type belonging to it can't enter any more till its 0. Good for e. g. DSL+ hubs.
if you set the the min_limit  to 0, then users of that connection type are not allowed to limit their upload.
Ex.: you can disable upload limit for LAN users if you would like to
For heaven's sake, please triple-check if the syntax is correct here, otherwise there will be trouble!!!
Only change the max_slots, min_ratio, max_hubs and min_limit numeric values! This is the correct syntax!
]]
Checks.SlotHubLimit.Rules={
			["28.8Kbps"]=
{--------- options for 28.8Kbps

			max_slots=0
,
			min_ratio=0
,
			max_hubs=0
,
			min_limit=0
},

			["33.6Kbps"]=
{--------- options for 33.6Kbps

			max_slots=0
,
			min_ratio=0
,
			max_hubs=0
,
			min_limit=0
},

			["56Kbps"]=
{--------- options for 56Kbps

			max_slots=10
,
			min_ratio=1
,
			max_hubs=20
,
			min_limit=5
},

			["Modem"]=
{--------- options for Modem

			max_slots=20
,
			min_ratio=1
,
			max_hubs=30
,
			min_limit=5
},

			["ISDN"]=
{--------- options for ISDN

			max_slots=4
,
			min_ratio=0.1
,
			max_hubs=20
,
			min_limit=6
},

			["GPRS"]=
{--------- options for GPRS

			max_slots=4
,
			min_ratio=1
,
			max_hubs=2
,
			min_limit=6
},

			["DSL"]=
{--------- options for DSL

			max_slots=20
,
			min_ratio=1
,
			max_hubs=30
,
			min_limit=8
},

			["Cable"]=
{-------- options for Cable

			max_slots=20
,
			min_ratio=1
,
			max_hubs=30
,
			min_limit=12
},

			["Wireless"]=
{-------- options for Wireless

			max_slots=30
,
			min_ratio=1
,
			max_hubs=30
,
			min_limit=8
},

			["Satellite"]=
{ -------- options for Satellite

			max_slots=8
,
			min_ratio=1
,
			max_hubs=30
,
			min_limit=8
},

			["LAN(T1)"]=
{ -------- options for LAN(T1)

			max_slots=50
,
			min_ratio=1
,
			max_hubs=30
,
			min_limit=20
},

			["LAN(T3)"]=
{ -------- options for LAN(T3)

			max_slots=120
,
			min_ratio=1
,
			max_hubs=30
,
			min_limit=0
}
}

--Values: 1 to disconnect, 2 to redirect
Checks.SlotHubLimit.BadLimitToDo=2
Checks.SlotHubLimit.BadHubToDo=2 
Checks.SlotHubLimit.BadRatioToDo=2
Checks.SlotHubLimit.BadSlotsToDo=2

--[[			    SHARE CHECKING STUFF
                            =====================
]]

-- Min share in gigabytes:
Checks.Share.MinShare=1

-- Following is in terabytes, good to keep out some brainless fakers
Checks.Share.MaxShare=2 

-- The next option defines who GET share checked.
Checks.Share.Level=2

-- Values: 1 to disconnect, 2 to redirect
Checks.Share.BadShareTodo=2


--[[			    CLONE CHECKING STUFF
                            =====================
]]

-- Bot will PM operators if clones found with same share and disconnected.
Checks.Clone.PMOps=1 
 
-- The next option defines who GET clone checked.
Checks.Clone.Level=3

--[[			    NICK CHECKING STUFF
                            =====================
                            
BETTER NOT CHANGE THE BADNICK TABLE IF YOU DON'T KNOW WHAT YOU ARE DOING!!!
]]

-- Note that bad characters always get checked in every nick!!!
Checks.Nick.BadChars = { " ", ";", ",", "%+", "°", "%^", "~",}

-- Check the nick prefix? If set to 0, the following 2 settings do not matter.
Checks.Nick.CheckPrefix=0


-- The next option defines who GET prefix checked.
Checks.Nick.Level=3

-- Define what prefixes can be used.
-- Can be anything between ( and { and [ and ] and } and ] , these can also be mixed.
-- note that check is case sensitive, so [hun] is not equal to [HUN]

Checks.Nick.PrefixesNeeded =
  {
    "[HUN]",
    "[EU]",
    "(HUN)",
  }

--[[
Now something new. With these prefixes, one can not enter the hub.
This one works even if prefix check is off.
Obviously these only affect unreg users, and should only contain the most necessary elements.
(Only unregs can have bad prefix, because a user using a bad prefix cannot be registered IMHO. :P)
]]

Checks.Nick.BadPrefixes=
        {
          "[OP]",
          "[VIP]",
          "[SU]",
        }

-- Values: 1 to disconnect, 2 to redirect
Checks.Nick.BadPrefixToDo=1

--[[
End of config.
Please do not edit below.
----------------------------------------------------------------------------------------
]]

Checks.ScanMyINFO=function(user) ----------
  local speed = user.sConnection
  local hubs,slots,Guest,Reg,OP
  if string.find(user.sConnection,"%(.+%/.+%)") then -- dirty workaround for R2++ et al. :-)
    _,_,speed=string.find(user.sConnection,"(.+)%(.+%/.+%)")
  end
  if not user.iRegHubs then
    if user.iHubs==0 then
      Guest,Reg,OP= 0 , 1 , 0
    else
      Guest,Reg,OP= user.iHubs, 1 , 0
    end
    else
      Guest,Reg,OP=user.iNormalHubs,user.iRegHubs,user.iOpHubs
    end
--   local _,_,Hubs,Slots,speed = string.find(myinfo, "H:([^,]+),S:(%d+).*>$ $([^$]+)[^$]%$")
--   local Guest,Reg,OP,slots,hubs,ratio
  local Maxslotsforconn,Ratioforconn,Maxhubsforconn,minlimitforconn=Checks.SlotHubLimit.Rules[speed].max_slots,Checks.SlotHubLimit.Rules[speed].min_ratio,Checks.SlotHubLimit.Rules[speed].max_hubs,Checks.SlotHubLimit.Rules[speed].min_limit
  local _,_,limit1=string.find(user.sMyInfoString,"[BLU]:(%d+)")
  local _,_,limit2 = string.find(user.sMyInfoString,"F:%d+/(%d+)")
  local temp = user.iShare
-- if tonumber (Hubs) then
--      if Hubs=="0" then
--              Guest,Reg,OP= "0", "1" , "0"
--      else
--              Guest,Reg,OP=  Hubs, "0", "0"
-- 	end
-- else
--      Guest,Reg,OP = user.iNormalHubs,user.iRegHubs,user.iOpHubs
-- end
  if Checks.SlotHubLimit.OpHubsCount==1 then
    hubs =Guest+Reg+OP
    slots=user.iSlots
    ratio=slots/hubs
  else
    hubs=Guest+Reg
    slots=user.iSlots
    if hubs==0 then
      ratio=slots
    else
      ratio=slots/hubs
  end
end
  local Share = string.format("%0.2f", user.iShareSize/gb)
  return hubs,slots,Guest,Reg,OP,speed,limit1 or limit2 or nil,Maxslotsforconn,Ratioforconn,Maxhubsforconn,minlimitforconn,ratio,Share
end


---------------- hub/slot/ratio checker
Checks.SlotHubLimit.CheckHubsAndSlots=function(user)
  local conn=user.sConnection
  if string.find(user.sConnection,"%(.+%/.+%)") then -- dirty workaround for R2++ et al. :-)
    _,_,conn=string.find(user.sConnection,"(.+)%(.+%/.+%)")
  end
  if not conn or not Checks.SlotHubLimit.Rules[conn] then
    user:SendData("ConnectionCheck","Your connection type could not be determined or is unknown.")
    Checks.Punish(user,"c",Checks.Client.BadClientToDo)
  else
    if Checks.SlotHubLimit.SlotHubLevel >= userlevels[user.iProfile] then
      if Immune and not Immune.List[user.sName] or not Immune then
        local hubs,slots,Guest,Reg,OP,speed,limit,Maxslotsforconn,Ratioforconn,Maxhubsforconn,minlimitforconn,ratio,Share=Checks.ScanMyINFO(user)
        if Maxslotsforconn==0 then -- kick unallowed
          user:SendData("ConnectionCheck","Your connection is "..speed..", which is not allowed in here.")
          user:Disconnect() return "shit"
        elseif slots>Maxslotsforconn then
          user:SendData("SlotperHubCheck","Too many slots! Maximum number of slots allowed for your "..speed.." connection: "..Maxslotsforconn..".")
          return Checks.Punish(user,"sl",Checks.SlotHubLimit.BadSlotToDo)
        elseif hubs>Maxhubsforconn then
          user:SendData("SlotperHubCheck","Too many hubs! You can be in maximum "..Maxhubsforconn.." hubs with your connection type, and you are in "..hubs.." now!")
          return Checks.Punish(user,"h",Checks.SlotHubLimit.BadHubToDo)
        elseif Ratioforconn > (ratio) then
          local min = tonumber(Ratioforconn)
          local minslotsforconn=min*hubs
          user:SendData("SlotperHubCheck","Your connection is "..speed..".")
          user:SendData("SlotperHubCheck","You are in "..hubs.." hubs, and have "..slots.." slots.")
          user:SendData("SlotperHubCheck","Open "..Ratioforconn.." slots per each hub for your connection type. (Currently you should have at least "..minslotsforconn.." slots open for this amount of hubs.")
          return Checks.Punish(user,"r",Checks.SlotHubLimit.BadRatioToDo)
        end
      end
    end
  end
end
-------------------------- limit check
Checks.SlotHubLimit.CheckLimit=function(user)
  if Checks.SlotHubLimit.LimitLevel >= userlevels[user.iProfile] then ---------------
    if Immune and not Immune.List[user.sName] or not Immune then
      local hubs,slots,Guest,Reg,OP,Speed,limit,Maxslotsforconn,Ratioforconn,Maxhubsforconn,minlimitforconn,ratio,Share=Checks.ScanMyINFO(user)
      if limit then
        if Checks.Client.Determine(user)~="DCGUI" then
          if minlimitforconn==0 then
            user:SendData("BandwidthCheck","No bandwith limiting allowed for a(n) "..Speed.." connection!")
            return Checks.Punish(user,"l",Checks.SlotHubLimit.BadLimitToDo)
          elseif tonumber(limit)<tonumber(minlimitforconn) then
            user:SendData("BandwidthCheck","Bandwith limit set too low! Minimum allowed for a(n) "..Speed.." speed is "..minlimitforconn.." kB/s, and you have "..limit.." kB/s.")
            return Checks.Punish(user,"l",Checks.SlotHubLimit.BadLimitToDo)
          end
        else
          if minlimitforconn==0 then
            user:SendData("BandwidthCheck","No bandwith limiting allowed for a(n) "..Speed.." connection!")
            return Checks.Punish(user,"l",Checks.SlotHubLimit.BadLimitToDo)
          elseif (tonumber(limit)*slots)<tonumber(minlimitforconn) then
            user:SendData("BandwidthCheck","Bandwith limit set too low! Minimum allowed for a(n) "..Speed.." speed is "..minlimitforconn.." kB/s, and you have "..limit.." kB/s.")
            return Checks.Punish(user,"l",Checks.SlotHubLimit.BadLimitToDo)
          end
        end
      end
    end
  end
end

Checks.Punish=function(user,whatsbad,what2do)
  local redtbl= 
          {
            ["sh"]=frmHub:GetShareRedirAddr(),
            ["l"]=frmHub:GetRedirectAddress(),
            ["sl"]=frmHub:GetSlotsRedirAddr(),
            ["h"]=frmHub:GetMaxHubsRedirAddr(),
            ["r"]=frmHub:GetRatioRedirAddr(),
	    ["c"]=frmHub:GetNoTagRedirAddr(),
          }
  if what2do==1 then user:Disconnect()
  else user:Redirect(redtbl[whatsbad] or frmHub:GetRedirectAddress())
  end
  return "shit"
end

------------------ share check
Checks.Share.Check=function(user) -- from channelbot
  if Checks.Share.Level >= userlevels[user.iProfile] then
    if Immune and not Immune.List[user.sName] or not Immune then
      local temp = user.iShareSize
      local minshare=Checks.Share.MinShare*gb
      local maxshare=Checks.Share.MaxShare*gb*1024
      if not temp then
        user:SendData("ShareCheck","I could not determine your share!  Disconnecting ... |")
        user:Disconnect() return "shit"
      end
      local Share = string.format("%0.2f", tonumber(temp)/gb)
      if tonumber(temp) < minshare then
        user:SendData("ShareCheck","You do not meet the share minimum ("..Checks.Share.MinShare.." GB)!")
        return(Checks.Punish(user,"sh",Checks.Share.BadShareTodo))
      elseif tonumber(temp) > maxshare then
	user:SendData("ShareCheck","Do you really think that I believe that you are sharing "..string.format("%0.2f", tonumber(temp)/(gb*1024)).." TBytes of data??? |")
	user:Disconnect() return "shit"
      end
    end
  end
end


---------------------------- client check part

Checks.Client.Patterns=
    {
	["<oDC"]={"oDC","V:(%d+.%d+)"},
	["<o%d+.%d+"]={"oDC","<o(%d+%.%d+)"},
	["reverseconnect.sf.net"]={"ReverseConnect","V:(0.%d+)"},
	["www.RevConnect.com"]={"ReverseConnect","V:(0.%d+)"},
	["<DCDM"]={"DCDM++","<DCDM%s+(0.%d+)"},
	["<RMDC++"]={"rmDC++","V:(0.%d+)"},
	["<DC@fe++"]={"DC@fe++","V:(0.%d+)"},
	["MS++V"]={"MS++V","V:(0.%d+)"},
	["<DC:PRO"]={"DC:PRO","V:([^,]+)."},
	["zDC++"]={"zDC++","V:(0.%d+)"},
	["<StrgDC++"]={"StrongDC++","V:([^,]+)."}, --<StrgDC++ V:1.00 RC10,M:A,H:2/1/2,S:5>
	["<.P>"]={".PhantomDC++","V:(0.%d+)"},
	["<CDM"]={"DC++k CDM","<CDM%s+(%d+.%d+)"},
	["<iDC"]={"iDC++","V:(0.%d+)"},
	["v%["]={"neXtDC++","V:(0.%d+)"},
	["[BL]:"]={"BCDC++","V:(0.%d+)"},
	["%[%d+%s*sl%]"]={"BCDC++","V:(0.%d+)"},
	["%[%d+[kM]%]"]={"BCDC++","V:(0.%d+)"},
	["V:%[Sasser.+"]={"Sasser","Sasser%s+(0.%d+)"},
        ["<So.eR++"]={"SoßeR++","%[(0.%d+)"},
	["<LDC++"]={"LDC++","V:(0.%d+)"},
	["<PWDC++"]={"PeerWebDC","V:(0.%d+)"},
	["%<%<%<sababadcpp%.6x%.to%>%>%>"]={"SababaDC++","V:(0.%d+)"},
	["<Z++"]={"Zion++","V:(%d+.%d+)"},
        ["<R2++"]={"R2++", "%[(.+)%]"},
        ["<Goofy++"]={"Goofy++","V:(0.%d+)"},
    }

Checks.Client.Determine=function(user)
  local clienttype, version
  if string.find(user.sMyInfoString,"<DCGUI") then 
    clienttype="DCGUI"
    _,_, version = string.find(user.sMyInfoString,"V:0.(%d+.%d+)")
  elseif user.bHasTag then --string.find(user.sMyInfoString,"<++") or string.find(user.sMyInfoString,"<oDC") or string.find(user.sMyInfoString,"<StrgDC++") or string.find(user.sMyInfoString,"<RMDC++") or string.find (user.sMyInfoString,"<DC:PRO") then
    for a,b in Checks.Client.Patterns do
      if string.find(user.sMyInfoString,a) then
        clienttype=b[1]
        _,_,version=string.find(user.sMyInfoString,b[2])
        break
      else
        clienttype = "DC++" 
        _,_,version=string.find(user.sMyInfoString,"V:(0.%d+)")
      end
    end
  end
  return clienttype,version
end

Checks.Client.Check=function(user)
  if Immune and not Immune.List[user.sName] or  not Immune then
    local clienttype,version=Checks.Client.Determine(user)
    local spec={["Sasser"]=1,["DC++k CDM"]=1,["DCDM++"]=1,["DC:PRO"]=1,["StrongDC++"]=1,["DCGUI++"]=1,["iDC++"]=1,["SoßeR++"]=1,["PeerWebDC"]=1,["Zion++"]=1,["R2++"]=1,["Goofy++"]=1}
    if clienttype then
      local fakes=
	{
	  [":%s+%S+,"]="Found spaces in the wrong place in the tag.",
	  ["%s+,"]="Found spaces in the wrong place in the tag.",
	  [",%s+"]="Found spaces in the wrong place in the tag.",
	  ["[\"\\]"]="Found backslash or quotation mark in the tag."
	}
      local bad
      for a,b in fakes do
	if string.find(user.sTag,a) then
	  bad=b
	end
      end
      if bad then return Checks.Client.Killfaker(user,bad) end
      if clienttype=="DCGUI" then 
        if not version then
          user:SendData("ClientCheck","You are hiding your DCGUI tag, or tag is corrupt!")
          return Checks.Punish(user,"c",Checks.Client.BadClientToDo)
        elseif (tonumber(version) < Checks.Client.DCGUIMinVersion) then
          user:SendData("ClientCheck","You are using DCGUI version 0."..dcgui)
          user:SendData("ClientCheck", "You are using a too old DCGUI client, use at least version 0."..Checks.Client.DCGUIMinVersion..".")
          return Checks.Punish(user,"c",Checks.Client.BadClientToDo)
        end
      else
	if not spec[clienttype] or clienttype=="DC++" then
	  if not version then
	    user:SendData("ClientCheck","You are hiding your DC++ tag, or tag is corrupt!")
	    return Checks.Punish(user,"c",Checks.Client.BadClientToDo)
	  else
	    if string.find(user.sTag,"%<%+%+.?V:") and not string.find(user.sTag,"%<%+%+%s+V:") then
	      return Checks.Client.Killfaker(user,"No space found in tag between characters + and V.")
	    end
	    local _,_,Hubs = string.find(user.sMyInfoString, "H:([^,]+),")
	    if not Hubs then
	      return Checks.Client.Killfaker(user,"Missing hubcount in tag, or hubcount contains invalid characters.")
	    else
	      if tonumber(version) >= 0.24 then
		if not string.find(Hubs,"%d+/%d+/%d+") then
		  return Checks.Client.Killfaker(user,"Hubcount contains invalid characters.")
		end
		if tonumber(Hubs) then
		  return Checks.Client.Killfaker(user,"Old-style hubcount with DC++ newer than 0.240.")
		else
		  if string.find(Hubs,"%D*0/0/[^0]") and not user.bOperator then
		    return Checks.Client.Killfaker(user,"0/0/x hubcount with not being op here.")
		  elseif string.find(Hubs,"%D*0/[^0]/%d+") and not user.bRegistered then
		    return Checks.Client.Killfaker(user,"0/x/x hubcount with not being registered here.")
		  end
		end
	      else
		if not tonumber(Hubs) then
		  return Checks.Client.Killfaker(user,"New-style (or non-numeric) hubcount with DC++ older than 0.240.")
		else
		  if Hubs=="0" and not user.bRegistered then
		    return Checks.Client.Killfaker(user,"0 hubcount with not being registered here.")
		  end
		end
	      end
	    end
	    if tonumber(version)<Checks.Client.DCppMinVersion then
	      user:SendData("ClientCheck","You are using "..clienttype..", version "..version)
	      user:SendData("ClientCheck","Too old DC++ version. Minimum version allowed is "..Checks.Client.DCppMinVersion)
	      return Checks.Punish(user,"c",Checks.Client.BadClientToDo)
	    end
	  end
	end
      end
    else
      if string.find(user.sMyInfoString, "dc-gui", 1, 1) or string.find(user.sMyInfoString, "dc.ketelhot.de", 1, 1) or string.find(user.sMyInfoString, "DCGUI", 1, 1) then 
	if not string.find(user.sMyInfoString, "<DCGUI V:", 1, 1) then 
	  user:SendData("ClientCheck", "You are hiding your DCGUI tag, you are now being disconnected!")
	  return Checks.Punish(user,"c",Checks.Client.BadClientToDo)
	end
      else
	user:SendData("ClientCheck","Invalid, hidden or missing tag!!! Please get DC++ or an appropriate mod, or DC:PRO! Linux users get DCGUI...")
	return Checks.Punish(user,"c",Checks.Client.BadClientToDo)
      end
    end
  end
end

function Checks.Client.Killfaker(user,why)
  user:SendData("ClientCheck","Your tag is faked! ("..why..")")
  if Checks.Client.BanFakeTag==1 then
    user:SendData("ClientCheck","You are now being banned"..aah())
    if Checks.SeeBotBan==1 then
      SendToAll("ClientCheck",user.sName.." has been banned for faked tag ("..why..")")
    end
    if Logging then Logging.Write("lawmaker/logs/"..os.date("%Y-%m-%d_").."botbanlog.log",user.sName.." "..os.date("%H:%M").." - (IP: "..user.sIP..") banned for faked tag. ("..why..")") end
    user:NickBan(); user:Ban() return "shit"
  else
    return Checks.Punish(user,"c",Checks.Client.BadClientToDo)
  end
end
  -- check if the client is for ops only, or not allowed
Checks.Client.CheckOpOnlyAndBad=function(user,clienttype)
  if Checks.Client.OpClients[clienttype]==1 and not user.bOperator then
    user:SendData("ClientCheck","This client ("..clienttype..") is for operators only.")
    return Checks.Punish(user,"c",Checks.Client.BadClientToDo)
  elseif Checks.Client.BadClients[clienttype]==1 then
    user:SendData("ClientCheck","This client ("..clienttype..") is not allowed here.")
    return Checks.Punish(user,"c",Checks.Client.BadClientToDo)
  end
end

Checks.Welcome=function(user)
  local proftable={[-1]="Guest",[0]="Superoperator",[1]="Operator",[2]="VIP",[3]="Registered User"}
  local prof=proftable[user.iProfile] or "<Unknown profile>" 
  user:SendData(Bot.name,"Hello, "..user.sName.."! You are logging in as "..prof..".")
  local hubs,slots,Guest,Reg,OP,speed,limit,Maxslotsforconn,Ratioforconn,Maxhubsforconn,minlimitforconn,ratio,Share=Checks.ScanMyINFO(user)
  if Immune and not Immune.List[user.sName] or not Immune then
    local clienttype,version=Checks.Client.Determine(user)
    user:SendData("ClientCheck","You are using "..clienttype..", version "..version..".")
    local v,u=bytestoh(user.iShareSize)
    user:SendData("ShareCheck","You are currently sharing "..v.." "..u..". The minimum share is currently set to "..Checks.Share.MinShare.." GB.")
    user:SendData("ConnectionCheck","Your connection is "..speed..". You are in "..getmode(user.sMyInfoString).." mode.")
    user:SendData("IPCheck","Your IP is "..user.sIP..".")
    user:SendData("SlotperHubCheck","You are on "..hubs.. " hub(s) in total. "..Guest.." as guest, "..Reg.." as registered, "..OP.." as operator.")
    user:SendData("SlotperHubCheck","Maximum hubs allowed for your connection is "..Maxhubsforconn..".")
    user:SendData("SlotperHubCheck","You have "..slots.." slots open. The maximum allowed for you is "..Maxslotsforconn..".")
    if tonumber(OP)>0 and Checks.SlotHubLimit.OpHubsCount==1 then
      user:SendData("SlotperHubCheck","Operator hubs count into total number of hubs.")
    elseif tonumber(OP)>0 then
      user:SendData("SlotperHubCheck","Operator hubs don't count into total number of hubs.")
    end
    user:SendData("SlotperHubCheck","According to these, your slot/hub ratio is "..ratio..".")
    user:SendData("SlotperHubCheck","The required minimum is "..Ratioforconn.." slots per each hub for this connection.")
    if minlimitforconn~=0 then
      if limit then
        if Checks.Client.Determine(user)=="DCGUI" then
          user:SendData("BandwidthCheck","Your upload limit is set to "..tonumber(limit)*slots.." kB/s, the minimum allowed for your class is "..minlimitforconn.." kB/s.")
        else
          user:SendData("BandwidthCheck","Your upload limit is set to "..limit.." kB/s, the minimum allowed for your class is "..minlimitforconn.." kB/s.")
        end
      else
        user:SendData("BandwidthCheck","You aren't limiting your upload, the minimum limit allowed for your connection is "..minlimitforconn.." kB/s.")
      end
    else
      user:SendData("BandwidthCheck","Bandwidth limiting is not allowed for your connection type.")
    end 
  else
    user:SendData(Bot.name,"You are immuned against checking. Therefore I won't send any info. Something for something! ;)")
  end
end

function Checks.Clone.Check(user,data)
  if Immune and not Immune.List[user.sName] or not Immune then
    for _,Nick in frmHub:GetOnlineUsers() do
      if user.sIP==Nick.sIP and not (Checks.Clone.Level >= userlevels[user.iProfile] or Checks.Clone.Level >= userlevels[Nick.iProfile] or not Immune.List[Nick.sName]) then
        if user.iShare==Nick.iShare then
          user:SendData(Bot.name,"This hub does not allow the use of clones. Hit the bricks, ya leecher!")
          Nick:SendData(Bot.name,"This hub does not allow the use of clones. Hit the bricks, ya leecher!")
          if Checks.Clone.PMOps == 1 then
            SendPmToOps(Bot.name, "*** Cloned user = "..user.sName.." logged in, Nick is a clone of = "..Nick.sName)
            SendPmToOps(Bot.name, "***"..user.sName.." and "..Nick.sName.." have been disconnected")
          end
          Nick:Disconnect(); user:Disconnect(); return "shit"
        else
          SendPmToOps(Bot.name, "*** User "..user.sName.." logged in, with same IP as "..Nick.sName.." but with different share, please check.")
        end
      end
    end
  end
end

function Checks.Main()
  frmHub: SetNoTagOption(1)
  Checks.Nick.Prefixes={Needed={},Bad={}}
  for k,v in pairs(Checks.Nick.BadPrefixes) do
    Checks.Nick.Prefixes.Bad[v]=1
  end
  if Checks.Nick.CheckPrefix==1 then -- save that resources :D
    Checks.Nick.Prefixes.List="\r\n====================\r\n"
    table.sort(Checks.Nick.PrefixesNeeded)
    for k,v in pairs(Checks.Nick.PrefixesNeeded) do
      Checks.Nick.Prefixes.Needed[v]=1
      Checks.Nick.Prefixes.List=Checks.Nick.Prefixes.List..v.."\r\n"
    end
    Checks.Nick.Prefixes.List=Checks.Nick.Prefixes.List.."====================\r\n\r\nNote that the check is case sensitive, a.k.a. [prefix] and [PREFIX] are different."
  end
end
  

function Checks.Nick.Check(user)
  for c=1,table.getn(Checks.Nick.BadChars ) do
    if string.find(user.sName,Checks.Nick.BadChars [c]) then
      local bdchr=string.gsub(Checks.Nick.BadChars [c],"%%","")
      user:SendData("NickNameCheck","Your nick contains the following invalid character (if nothing shows, it's a space): "..bdchr)
      user:SendData("NickNameCheck","Please correct it and reconnect! Try using only numbers, letters, brackets, underscores and hyphens.")
      user:SendData("NickNameCheck","Disconnects...")
      user:Disconnect()
      return "shit"
    end
  end
  if Immune and not Immune.List[user.sName] or not Immune then
    local _,_,prefix = string.find(user.sName, "^([%[%{%(]%S+[%)%}%]])%S+")
    if prefix and Checks.Nick.Prefixes.Bad[prefix] and not user.bRegistered then
      user:SendData("NickNameCheck", prefix.." - This prefix is not allowed for you to use.")
      user:Disconnect() return "shit"
    end
    if userlevels[user.iProfile] <= Checks.Nick.Level then
      if Checks.Nick.CheckPrefix==1 then
        if prefix then
          if not Checks.Nick.Prefixes.Needed[prefix] then
            user:SendData("NickNameCheck", "\r\nBad prefix, use one of these:"..Checks.Nick.Prefixes.List)
            if Checks.Nick.BadPrefixToDo==1 then
              user:Disconnect()
            else
              user:Redirect(frmHub:GetNickRuleRedirAddr())
            end
            return "shit"
          end
        else
          user:SendData("NickNameCheck", "\r\nNo prefix specified, use one of these:"..Checks.Nick.Prefixes.List)
          if Checks.Nick.BadPrefixToDo==1 then
            user:Disconnect()
          else
            user:Redirect(frmHub:GetNickRuleRedirAddr())
          end
          return "shit"
        end
      end
    end
  end
end

function Checks.SlotHubLimit.Show(user,data,env)
  local array={}
  local msg="\r\nThese are the slot/hub/limit rules:\r\n\r\n========================================================================================\r\nConnection type\t#\tMax. slots\t\t    Ratio\t\tMax. hubs\tMin.limit\r\n========================================================================================\r\n"
  for a,b in Checks.SlotHubLimit.Rules do
    if b.max_slots==0 then
      c=a.."\t\t#\t\t\tCONNECTION TYPE NOT ALLOWED"
    else
      local d
      if b.min_limit==0 then d="Not allowed" else d=b.min_limit.." kB/s" end
      c=a.."\t\t#\t"..b.max_slots.." slots\t\t"..b.min_ratio.." slots per hub\t   "..b.max_hubs.." hubs\t\t"..d
    end
    table.insert(array,c)
    table.sort(array)
  end
  for s=1,table.getn(array) do
    msg=msg..array[s].."\r\n========================================================================================\r\n"
  end
  user:SendPM(Bot.name,msg)--.."\r\nNote: \t0 max. slots means that connection is not allowed in this hub.\r\n \t0 min. limit means that no limiting allowed for that connection type.")
  local speed = user.sConnection
  if string.find(user.sConnection,"%(.+%/.+%)") then -- dirty workaround for R2++ et al. :-)
    _,_,speed=string.find(user.sConnection,"(.+)%(.+%/.+%)")
  end
  local Rulz=Checks.SlotHubLimit.Rules[speed]
  local msg="\r\nRules for your connection type ("..speed..")  are:\r\n====================================\r\n\r\n"
  if Rulz.max_slots==0 then user:SendPM(Bot.name,msg.."Your connection is not allowed in here, you are probably imumned.") return 1 end
  msg=msg.."Max. slots: "..Rulz.max_slots..
  "\r\nMin. slot/hub ratio: "..Rulz.min_ratio.." slots per each hub."..
  "\r\nMax hubs: "..Rulz.max_hubs..
  "\r\nMin. limit: "
  if Rulz.min_limit==0 then msg=msg.."Limiting not allowed" else msg=msg..Rulz.min_limit.." kB/s" end
  user:SendPM(Bot.name,msg)
end

-- The following is a dirty trick.
-- It is not enough to call checks on NewUserConnected, but the double login can make false kicks.
-- So these checks run only if the user sending MyINFO is connected.
-- It is not sure that he will be connected after the checks. :P
function Checks.MyINFOArrival(user,data)
  if user.bConnected then
    local torun=
      {
	Checks.Client.Check,
	Checks.Share.Check,
	Checks.SlotHubLimit.CheckHubsAndSlots,
	Checks.SlotHubLimit.CheckLimit,
      }
    for a=1,table.getn(torun) do
      if torun[a](user)=="shit" then
	break
      end
    end
  end
end

--------------------------------------------------------------------------------=======================================================

RegFunc("nuc","check client",Checks.Client.Check,{})
RegFunc("nuc","check nick",Checks.Nick.Check,{})
RegFunc("nuc","check share",Checks.Share.Check,{})
RegFunc("nuc","check hubs/slots",Checks.SlotHubLimit.CheckHubsAndSlots,{})
RegFunc("nuc","check limiter",Checks.SlotHubLimit.CheckLimit,{})
RegFunc("nuc","welcome",Checks.Welcome,{})
RegFunc("nuc","clone check",Checks.Clone.Check,{})
RegFunc("myinfo","checking an ALREADY CONNECTED user",Checks.MyINFOArrival,{})
RegFunc("main","making lists needed for checks",Checks.Main,{})
RegCmd("slothublimit",Checks.SlotHubLimit.Show,{},1,"\t\t\t\t\tShows a table on slot/hub/limit rules by connection type.")
RegRC(1,"1 3","Info\\Hub info\\Show slot/hub/limit rules","!slothublimit")